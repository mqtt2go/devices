#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <TroykaDHT.h>
#include <ArduinoJson.h>
#include "FS.h"
#include <time.h>
#include "ESP8266mDNS.h"

#define MAX_TOPICS 6
#define MAX_TOPIC_LEN 42
#define BROKER_URL_LEN 20
#define SSID_LEN 32
#define BUFF_LEN 384

#define EMPTY_STATE 0
#define START_STATE 1
#define START_STATE_I 2
#define WIFI_STATE 3
#define WIFI_STATE_I 4
#define JOINT_STATE 5
#define TOPIC_STATE 6
#define TOPIC_STATE_I 7
#define INITIALIZE_STATE 8
#define INITIALIZED_STATE 9
#define BTN_PIN 0
#define RELAY_PIN 12
#define LED_PIN 13

#define DOMAIN_RESOLVE (char*) "MQTT2GO.local"
#define REQ_SSID (char*) "MQTT2GO_Config"
#define TOPICS_FILES (char*) "/topics.txt"
#define LOGIN_FILES (char*) "/login.txt"
#define CERT_FILE (char*) "/cert.crt"
#define WIFI_FILE (char*) "/wifi.txt"

#define CLIENT_ID (char*) "TH16"
#define ACTIVATION_CODE (char*) "123456"

#define ACTIVATION_TOPIC ACTIVATION_CODE "/activation" 
#define WIFI_TOPIC ACTIVATION_CODE "/wifi" 
#define TOPICS_TOPIC CLIENT_ID "/topics"

char mqttUser[20] = {0};
char mqttPswd[20] = {0};
char wifiSSID[SSID_LEN] = {0};
char wifiPswd[20] = {0};

char cert[64] = {0};
uint16_t port = 0;
char mqttServer[BROKER_URL_LEN] = {0};
char hostString[16] = {0};


StaticJsonDocument<BUFF_LEN> doc;
char buffer[BUFF_LEN] = {0};
char topics[MAX_TOPICS][MAX_TOPIC_LEN];
uint8_t topicsNum = 0;
uint8_t state = EMPTY_STATE;
unsigned long lastMsg = 0;

WiFiClientSecure espClient;
PubSubClient client(espClient);
DHT dht(14, DHT21);

unsigned long pressStart = 0;
boolean pressed = 0;

static const char *fingerprint PROGMEM = "63 7B 21 A6 28 2E 5F 2C 46 C0 C7 E8 5D E2 B4 70 2F 74 4B 53";

void setPower(const char* command){
  if (strcmp(command, "off") == 0){
      digitalWrite(RELAY_PIN, LOW);
  }
  if (strcmp(command, "on") == 0){
    digitalWrite(RELAY_PIN, HIGH);
  }
}

void createCommandHeader(char* command_t, char *value){
  doc.clear();
  doc["type"] = "command";
  doc["timestamp"] = (uint32_t) time(nullptr);
  doc["command_type"] = command_t;
  doc["value"] = value;
}

void reportValues(){
  dht.read();
  doc.clear();
  doc["type"] = "report";
  doc["priority_level"] = 1;
  doc["report_type"] = "periodic_report";
  doc["timestamp"] = (uint32_t) time(nullptr);
  for (uint8 i = 0; i < topicsNum; i++)
  {
    if(strstr(topics[i], "temperature") != NULL){
      doc["report_name"] = "temperature";
      doc["report"] = dht.getTemperatureC();
      serializeJson(doc, buffer);
      client.publish(topics[i], buffer);
    }
    if(strstr(topics[i], "humidity") != NULL){
      doc["report_name"] = "humidity";
      doc["report"] = dht.getHumidity();
      serializeJson(doc, buffer);
      client.publish(topics[i], buffer);
    }
  }
}

void callback(char* topic, byte* payload, unsigned int length){
  payload[length] = 0;
  doc.clear();
  DeserializationError error = deserializeJson(doc, (char*) payload);
  if(!error){
    if (doc["type"] == "command"){
      if (strstr(topic, "/power") != NULL && doc["command_type"] == "set"){
          setPower(doc["value"]);
      }
      if (strstr(topic, "/remove") != NULL && doc["command_type"] == "remove"){
        client.disconnect();
        SPIFFS.format();
        delay(1000);
        ESP.restart();
      }
    }
  }
}


void reconnect(bool isAnonyme){
  while (!client.connected())
  {
    if (isAnonyme){
      client.connect(CLIENT_ID);
    } else {
      client.connect(CLIENT_ID, mqttUser, mqttPswd);
    }
    if (!client.connected()){
        delay(5000);
    }
  }
}


void loadTopics(){
  File f = SPIFFS.open(TOPICS_FILES, "r");
  uint8_t i = 0;
  while (f.available())
  {
    buffer[0] = '\0';
    uint16_t l = f.readBytesUntil('\n', buffer, sizeof(buffer));
    buffer[l] = '\0';
    strcpy(topics[i], buffer);
    i++;
  }
  topicsNum = i;
  f.close();
}

void storeTopics(){
 File f = SPIFFS.open(TOPICS_FILES, "w+");
  for (uint8_t i = 0; i < topicsNum; i++)
  {
    f.print(topics[i]);
    f.print('\n');
  }
  f.close();
}

void loadCredentials(char* name, char* password, char* file){
  File f = SPIFFS.open(file, "r");
  buffer[0] = '\0';
  uint16_t l = f.readBytesUntil('\n', buffer, sizeof(buffer));
  buffer[l] = '\0';
  strcpy(name, buffer);
  buffer[0] = '\0';
  l = f.readBytesUntil('\n', buffer, sizeof(buffer));
  buffer[l] = '\0';
  strcpy(password, buffer);
  f.close();
}

void storeCredentials(char* name, char* password, char* file){
  File f = SPIFFS.open(file, "w+");
  f.print(name);
  f.print('\n');
  f.print(password);
  f.print('\n');
  f.close();
}

void storeCert(){
  File f = SPIFFS.open(CERT_FILE, "w+");
  f.print(cert);
  f.print('\n');
  f.close();
}

void loadCert(){
  File f = SPIFFS.open(CERT_FILE, "r");
  uint16_t l = f.readBytesUntil('\n', buffer, sizeof(buffer));
  buffer[l] = '\0';
  strcpy(cert, buffer);
  f.close();
}

void firstCallback(char* topic, byte* payload, unsigned int length){
  if (strcmp(topic, ACTIVATION_TOPIC) == 0 || strcmp(topic, WIFI_TOPIC) == 0 || strcmp(topic, TOPICS_TOPIC) == 0){
    payload[length] = 0;
    doc.clear();
    DeserializationError error = deserializeJson(doc, (char*)payload);
    if (!error){
      if(doc["type"] == "report" && doc["report_name"] == "mqtt_credentials"){
        strcpy(mqttUser, doc["value"]["user"]);
        strcpy(mqttPswd, doc["value"]["password"]);
        strcpy(cert, doc["value"]["cert"]);
        storeCredentials(mqttUser, mqttPswd, LOGIN_FILES);
        storeCert();
        state = WIFI_STATE;
        lastMsg = 0;
      }
      else if(doc["type"] == "report" && doc["report_name"] == "wifi_credentials"){
        strcpy(wifiSSID, doc["value"]["SSID"]);
        strcpy(wifiPswd, doc["value"]["password"]);
        storeCredentials(wifiSSID, wifiPswd, WIFI_FILE);
        state = JOINT_STATE;
        lastMsg = 0;
      }
      else if(doc["type"] == "report" && doc["report_name"] == "topics"){
        client.unsubscribe(TOPICS_TOPIC);
        //state = INITIALIZE_STATE;
        client.setCallback(callback);
        uint8_t i = 0;
        JsonArray arr = doc["value"].as<JsonArray>();
        for (JsonVariant value : arr){
          strcpy(topics[i], value.as<char*>());
          i++;
        }
        topicsNum = i;
        storeTopics();
        client.disconnect();
        ESP.restart();
      }
    }
  }
}

void getTime(){
  configTime(8 * 3600, 0, "pool.ntp.org");
  time_t now = time(nullptr);
  while (now < 1000) {
    delay(500);
    now = time(nullptr);
  }
}

void findIP(){
  while (port == 0){
    int n = MDNS.queryService("mqtt", "tcp");
    for (uint8_t i = 0; i < n; i++){
      MDNS.hostname(i).toCharArray(buffer, BROKER_URL_LEN);
      if (strcmp(buffer, DOMAIN_RESOLVE) == 0){
        MDNS.IP(i).toString().toCharArray(buffer, BROKER_URL_LEN);
        strcpy(mqttServer, buffer);
        port = MDNS.port(i);
      }
    }
  }
}

void findWifi(){
  while (strlen(wifiSSID) == 0)
  {
    uint8_t wifiNum = WiFi.scanNetworks();
    for (uint8_t i = 0; i < wifiNum; i++){
      WiFi.SSID(i).toCharArray(buffer, SSID_LEN);
      if(strcmp(buffer, REQ_SSID) == 0){
        strcpy(wifiSSID, buffer);
        break;
      }
    }
  }
}

void ICACHE_RAM_ATTR pressHandler(){
    if (digitalRead(BTN_PIN) == LOW){
      pressStart = millis();
      pressed = 1;
    }
    if (digitalRead(BTN_PIN) == HIGH && millis() - pressStart > 5000)
    {
      Serial.println("Factory reset");
      digitalWrite(LED_PIN, LOW);
      SPIFFS.format();
      delay(500);
      ESP.restart();
    } 
}

void setup() {
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BTN_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);
  attachInterrupt(digitalPinToInterrupt(BTN_PIN), pressHandler, CHANGE);
  Serial.begin(9600);
  delay(100);
  SPIFFS.begin();
  boolean configured = SPIFFS.exists(TOPICS_FILES);
  
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  delay(100);

  if (configured){
    loadCredentials(wifiSSID, wifiPswd, WIFI_FILE);
    WiFi.begin(wifiSSID, wifiPswd);
  }else{
    findWifi();
    WiFi.begin(wifiSSID);
  }

  while (WiFi.status() != WL_CONNECTED){
    delay(1000);
  }

  delay(1000);
  for (uint8_t i = 0; i < 3; i++)
  {
    getTime();
    delay(500);
  }

  MDNS.begin(hostString);

  findIP();
 
  randomSeed(micros());
  delay(200);

  client.setServer(mqttServer, port);
  
  if (configured == false){
      SPIFFS.format();
      espClient.setFingerprint(fingerprint);
      client.setCallback(firstCallback);
      reconnect(true);
      state = START_STATE;
  } else {
      loadCredentials(mqttUser, mqttPswd, LOGIN_FILES);
      loadTopics();
      loadCert();                                                                                                          
      espClient.setFingerprint(cert);
      state = INITIALIZE_STATE;
      reconnect(false);
      client.setCallback(callback);
  }
}

void loop() {
    switch (state)
    {
    case START_STATE:
      client.subscribe(ACTIVATION_TOPIC);
      state = START_STATE_I;
      break;
    case START_STATE_I:
      if (millis() - lastMsg > 10000){
        createCommandHeader((char *) "mqtt_credentials", (char *) "GET_CREDENTIALS");
        serializeJson(doc, buffer);
        client.publish(ACTIVATION_TOPIC, buffer);
        lastMsg = millis();
      }
      break;
    case WIFI_STATE:
      client.subscribe(WIFI_TOPIC);
      state = WIFI_STATE_I;
      break;
    case WIFI_STATE_I:
      if (millis() - lastMsg > 10000){
        createCommandHeader((char *) "wifi_credentials", (char *) "GET_WIFI_CREDENTIALS");
        serializeJson(doc, buffer);
        client.publish(WIFI_TOPIC, buffer);
        lastMsg = millis();
      }
      break;
    case JOINT_STATE:
      client.disconnect();
      WiFi.disconnect();
      WiFi.begin(wifiSSID, wifiPswd);
      while (WiFi.status() != WL_CONNECTED){
        delay(1000);
      }
      reconnect(false);
      client.subscribe(TOPICS_TOPIC);
      state = TOPIC_STATE;
      break;
    case TOPIC_STATE:
      if (millis() - lastMsg > 10000){
        createCommandHeader((char *) "topics", (char *) "GET_DEVICE_TOPICS");
        serializeJson(doc, buffer);
        client.publish(TOPICS_TOPIC, buffer);
        lastMsg = millis();
      }
      break;
    case INITIALIZE_STATE:
      for (uint8_t i = 0; i < topicsNum; i++)
      {
        client.subscribe(topics[i]);
      }
      dht.begin();
      state = INITIALIZED_STATE;
      break;
    case INITIALIZED_STATE:
      if (millis() - lastMsg > 10000){
          reportValues();
          lastMsg = millis();
      }
    break;
    default:
      break;
    }
    client.loop();
    //MDNS.update();
}